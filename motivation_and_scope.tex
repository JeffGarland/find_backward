\section{Motivation and Scope}

Consider how finding the last element that is equal to `x` in a range is
typically done (for all the examples below, we assume a valid range of
elements \code{[first, last)}, and an iterator \code{it} within that range):

\lstinputlisting[language=C++, firstline=3, lastline=7]{snippets.cpp}

Raw loops are icky though.  Perhaps we should do a bit of extra work to allow
the use of \code{find()}:

\lstinputlisting[language=C++, firstline=12, lastline=15]{snippets.cpp}

That seems nicer in that there is no raw loop, but it has major drawbacks.
First, it requires an unpleasant amount of typing.  Second, it is less
efficient than forward-iterator \code{find()} , since \code{reverse_iterator}
calls its base-iterator's \code{operator--()} in most of its member functions
before doing the work that the member function requires.

Consider this instead:

\lstinputlisting[language=C++, firstline=41, lastline=42]{snippets.cpp}

That's better!  It's a lot less verbose and is more efficient too.

Another drawback is the lack of clarity of the \code{make_reverse_iterator()}
code.  In a typical use of \code{find()}, I search forward from the element I
start from, including the element itself:

\lstinputlisting[language=C++, firstline=20, lastline=20]{snippets.cpp}

However, using finding in reverse in the middle of a range leaves out the
element pointed to by the current iterator:

\lstinputlisting[language=C++, firstline=25, lastline=28]{snippets.cpp}

That leads to code like this:

\lstinputlisting[language=C++, firstline=33, lastline=36]{snippets.cpp}

Though this looks like an off-by-one error. is is correct.  Moreover, even
though the use of \code{next()} is correct, it gets lost in noise of the rest
of the code, since it is so verbose.  Use \code{find_backward()} makes things
clearer:

\lstinputlisting[language=C++, firstline=47, lastline=51]{snippets.cpp}

The use of \code{next()} may at first appear like a mistake, until the reader
takes a moment to think things through.  In the \code{reverse_iterator}
version, this correctness is a lot harder to readily grasp.

\subsubsection{\code{find_not()}}

One more thing.  Consider this use of \code{find()}:

\lstinputlisting[language=C++, firstline=57, lastline=58]{snippets.cpp}

This gives us the first occurance of \code{1} in \code{vec}.  What if we want
to find the first occurrance of any number besides \code{1} in \code{vec}?  We
have to write an unfortunate amount of code:

\lstinputlisting[language=C++, firstline=63, lastline=64]{snippets.cpp}

With \code{find_not()} the code gets much more terse:

\lstinputlisting[language=C++, firstline=69, lastline=70]{snippets.cpp}

The existing \code{find} variants are: \code{find()}, \code{find_if()}, and
\code{find_if_not()}.  It seems natural to also have \code{find_not()}, for
the very reason that we have \code{find_if_not()} -- to avoid having to write
a lambda to wrap the negation of the find condition.
